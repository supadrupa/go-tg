// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package tg

import (
	"context"
	"io"
	"sync"
)

var (
	lockTransportMockDownload sync.RWMutex
	lockTransportMockExecute  sync.RWMutex
)

// Ensure, that TransportMock does implement Transport.
// If this is not the case, regenerate this file with moq.
var _ Transport = &TransportMock{}

// TransportMock is a mock implementation of Transport.
//
//     func TestSomethingThatUsesTransport(t *testing.T) {
//
//         // make and configure a mocked Transport
//         mockedTransport := &TransportMock{
//             DownloadFunc: func(ctx context.Context, token string, path string) (io.ReadCloser, error) {
// 	               panic("mock out the Download method")
//             },
//             ExecuteFunc: func(ctx context.Context, r *Request) (*Response, error) {
// 	               panic("mock out the Execute method")
//             },
//         }
//
//         // use mockedTransport in code that requires Transport
//         // and then make assertions.
//
//     }
type TransportMock struct {
	// DownloadFunc mocks the Download method.
	DownloadFunc func(ctx context.Context, token string, path string) (io.ReadCloser, error)

	// ExecuteFunc mocks the Execute method.
	ExecuteFunc func(ctx context.Context, r *Request) (*Response, error)

	// calls tracks calls to the methods.
	calls struct {
		// Download holds details about calls to the Download method.
		Download []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token string
			// Path is the path argument value.
			Path string
		}
		// Execute holds details about calls to the Execute method.
		Execute []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// R is the r argument value.
			R *Request
		}
	}
}

// Download calls DownloadFunc.
func (mock *TransportMock) Download(ctx context.Context, token string, path string) (io.ReadCloser, error) {
	if mock.DownloadFunc == nil {
		panic("TransportMock.DownloadFunc: method is nil but Transport.Download was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Token string
		Path  string
	}{
		Ctx:   ctx,
		Token: token,
		Path:  path,
	}
	lockTransportMockDownload.Lock()
	mock.calls.Download = append(mock.calls.Download, callInfo)
	lockTransportMockDownload.Unlock()
	return mock.DownloadFunc(ctx, token, path)
}

// DownloadCalls gets all the calls that were made to Download.
// Check the length with:
//     len(mockedTransport.DownloadCalls())
func (mock *TransportMock) DownloadCalls() []struct {
	Ctx   context.Context
	Token string
	Path  string
} {
	var calls []struct {
		Ctx   context.Context
		Token string
		Path  string
	}
	lockTransportMockDownload.RLock()
	calls = mock.calls.Download
	lockTransportMockDownload.RUnlock()
	return calls
}

// Execute calls ExecuteFunc.
func (mock *TransportMock) Execute(ctx context.Context, r *Request) (*Response, error) {
	if mock.ExecuteFunc == nil {
		panic("TransportMock.ExecuteFunc: method is nil but Transport.Execute was just called")
	}
	callInfo := struct {
		Ctx context.Context
		R   *Request
	}{
		Ctx: ctx,
		R:   r,
	}
	lockTransportMockExecute.Lock()
	mock.calls.Execute = append(mock.calls.Execute, callInfo)
	lockTransportMockExecute.Unlock()
	return mock.ExecuteFunc(ctx, r)
}

// ExecuteCalls gets all the calls that were made to Execute.
// Check the length with:
//     len(mockedTransport.ExecuteCalls())
func (mock *TransportMock) ExecuteCalls() []struct {
	Ctx context.Context
	R   *Request
} {
	var calls []struct {
		Ctx context.Context
		R   *Request
	}
	lockTransportMockExecute.RLock()
	calls = mock.calls.Execute
	lockTransportMockExecute.RUnlock()
	return calls
}
